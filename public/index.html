<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Avatar Tester</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="color"] { width: calc(100% - 22px); padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        .avatar-preview { margin-top: 20px; text-align: center; }
        .avatar-preview img { width: 100px; height: 100px; border: 1px solid #ddd; border-radius: 4px; background-color: #eee; }
        .info { font-size: 0.9em; color: #555; }
        h1 { color: #333; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

    <script type="text/babel">
        /**
         * Debounce function to limit the rate at which a function can fire.
         * @param {Function} func The function to debounce.
         * @param {number} delay The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        function App() {
            /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
            const [name, setName] = React.useState('Alterya');
            /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
            const [bgColor, setBgColor] = React.useState('FFDBAC'); // Store without #
            /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
            const [imageUrl, setImageUrl] = React.useState('');
            /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
            const [requestUrl, setRequestUrl] = React.useState('');
            /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
            const [error, setError] = React.useState('');
            
            const previousObjectUrlRef = React.useRef(null);

            // Assuming server runs on localhost:3000 based on assignment and server fallback.
            // Your server's DEFAULT_PORT is taken from process.env.PORT or defaults to 3000.
            // const SERVER_BASE_URL = 'http://localhost:3000'; // Removed

            const generateAndSetImageUrl = React.useCallback(debounce(async (currentName, currentBgColor) => {
                if (previousObjectUrlRef.current) {
                    URL.revokeObjectURL(previousObjectUrlRef.current);
                    previousObjectUrlRef.current = null;
                }
                setImageUrl(''); // Clear previous image immediately

                if (!currentName.trim()) {
                    setError('Name is a mandatory parameter.');
                    setRequestUrl('');
                    return;
                }
                
                const params = new URLSearchParams();
                params.append('name', currentName.trim());
                
                const cleanBgColor = currentBgColor.replace('#', '');
                if (cleanBgColor) {
                    params.append('backgroundColor', cleanBgColor);
                }
                
                const generatedRequestUrl = `/user-avatar?${params.toString()}`;
                setRequestUrl(generatedRequestUrl);

                try {
                    const response = await fetch(generatedRequestUrl);
                    if (!response.ok) {
                        let errorMsg = `Server error: ${response.status} ${response.statusText || ''}`;
                        try {
                            const errorData = await response.json();
                            // Check for the specific error structure provided
                            if (errorData && Array.isArray(errorData.errors) && errorData.errors.length > 0) {
                                errorMsg += ` - ${errorData.errors[0].msg}`;
                                if (errorData.errors[0].path) {
                                   errorMsg += ` (Parameter: ${errorData.errors[0].path})`;
                                }
                            } else if (errorData && errorData.message) { // Fallback for other JSON errors
                                errorMsg += ` - ${errorData.message}`;
                            } else if (errorData && errorData.error) { // Another fallback
                                 errorMsg += ` - ${errorData.error}`;
                            }
                        } catch (e) {
                            // Not a JSON error response, or failed to parse. Try to get text.
                            const textError = await response.text();
                            if (textError) {
                                errorMsg += ` - ${textError.substring(0, 100)}`; // Limit length of non-JSON error text
                            }
                        }
                        setError(errorMsg.trim());
                        setImageUrl('');
                        return;
                    }

                    const blob = await response.blob();
                    if (blob.type && !blob.type.startsWith('image/')) {
                        setError(`Server returned non-image data: ${blob.type}`);
                        setImageUrl('');
                        return;
                    }
                    const objectUrl = URL.createObjectURL(blob);
                    previousObjectUrlRef.current = objectUrl;
                    setImageUrl(objectUrl);
                    setError('');

                } catch (err) {
                    console.error('Fetch error:', err);
                    setError(`Network error or server unavailable: ${err.message}`);
                    setImageUrl('');
                }
            }, 300), []); // Dependencies: name, bgColor handled by useEffect calling this

            React.useEffect(() => {
                generateAndSetImageUrl(name, bgColor);

                // Cleanup on unmount
                return () => {
                    if (previousObjectUrlRef.current) {
                        URL.revokeObjectURL(previousObjectUrlRef.current);
                    }
                };
            }, [name, bgColor, generateAndSetImageUrl]);

            const handleNameChange = (event) => {
                setName(event.target.value);
            };

            const handleBgColorChange = (event) => {
                setBgColor(event.target.value.replace('#', ''));
            };
            
            // This handler is now for issues if the blob isn't a valid image after a successful fetch
            const handleImageError = () => {
                setError('Failed to display image. The fetched data might not be a valid image format.');
                // Keep previousObjectUrlRef.current as is, because it's already tried to load.
                // Setting imageUrl to '' would hide the broken image icon but also the chance to see what went wrong.
            }

            return (
                <div className="container">
                    <h1>User Avatar API Tester</h1>
                    <p className="info">
                        Ensure your Node.js server is running. The avatar should update automatically as you type.
                    </p>
                    
                    <div className="parameters-section">
                        <h2>Parameters</h2>
                        <div className="form-group">
                            <label htmlFor="name">Name (Mandatory):</label>
                            <input
                                type="text"
                                id="name"
                                value={name}
                                onChange={handleNameChange}
                                placeholder="Enter user name"
                            />
                        </div>
                        <div className="form-group">
                            <label htmlFor="bgColor">Background Color (Optional Hex):</label>
                            <input
                                type="text"
                                id="bgColor"
                                value={bgColor} // Display without #
                                onChange={handleBgColorChange}
                                placeholder="e.g., FFDBAC or ca8a04"
                            />
                             <p className="info">Enter a hex color code (e.g., FFDBAC, #CA8A04). The server handles formats with/without '#'.</p>
                        </div>
                    </div>

                    {requestUrl && (
                        <div className="request-url-section">
                            <h2>Request URL</h2>
                            <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all', backgroundColor: '#f0f0f0', padding: '10px', borderRadius: '4px' }}>
                                <code>{requestUrl}</code>
                            </pre>
                        </div>
                    )}

                    <div className="response-preview-section">
                        <h2>Avatar Preview</h2>
                        <div className="avatar-preview">
                            {imageUrl ? (
                                <img 
                                    src={imageUrl} 
                                    alt={`Avatar for ${name}`} 
                                    onError={handleImageError} 
                                />
                            ) : (
                                <p>{error ? '' : 'Enter a name to see the avatar.'}</p>
                            )}
                            {error && <p style={{color: 'red', marginTop: '10px'}}>{error}</p>}
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html> 